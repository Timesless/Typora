>
>
>排序
>
>基础数据结构： 链表，栈，队列，哈希表
>
>高级数据结构：堆，二叉树，图
>
>基础算法：深度优先，广度优先，递归
>
>基本算法思想：递归，分支，回溯，贪心，动态规划
>
>
>
>时钟周期  t = 1 / f
>
>机器周期：包含多个时钟周期
>
>指令周期：包含多个机器周期
>
>MIPS：每秒执行百万指令数
>
>1s之内解决问题：
>
>On<sup>2</sup>处理10<sup>4</sup>级别数据
>
>On算法处理10<sup>8</sup>级别数据
>
>
>
>递归函数的时间复杂度： 主定理
>
>
>
>优化
>
>+ 遍历常见算法思路
>+ 遍历常见数据结构
>+ 空间换时间（哈希表）
>
> 
>
>双指针
>
>+ 对撞指针
>+ 滑动窗口
>+ 三路快排 | 两路快排

``` js
// 字符串
// 数组
// 链表
// 栈（模拟递归）
// 队列（树层次遍历，无权图最短路径）
// 递归 100，101，110，111，112（基准情形），113，129，222，257，404
// BST 108，230，450

/**
 * 回溯（树型结构，树的叶节点对应终结状态）
 * 是一个暴力解法（使用减支，动态规划来优化）
 * 17，46（状态恢复），37，39，40，47，51（N-Queens），52，77，78，90，216，401
 *
 * 二维平面回溯
 * 79，130，200（floodfill），417
 */

```

#### 动态规划

``` java
/**
 * 动态规划
 * 递归 | 记忆化搜索是自顶向下解决问题。
 * 动态规划自底向上解决问题。
 * 
 * 求一个问题的最优解（最大最小值）
 * 1. 重叠子问题，最优子结构（原问题的最优解依赖于各个子问题的最优解）
 *		子问题的最优解，可以存储起来（通常是一维或二维数组）
 * 2. 每一步面临若干选择，由于我们事先不知道最优解，只好遍历所有可能并比较得到最优解
 *
 * 贪心算法不一样，基于一个贪婪选择，我们确定能得到最优解，需要用数学的方式证明贪心选择的正确性
 */

// 递归
long fibonacci(int n) {
    in (n < 2)
        return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// int[] memo = new int[n + 1];
// memo[1] = 1;
// memo[2] = 1;

// 记忆化递归，自顶向下
long fibonacci(int[] memo, int n) {
    // 初值需要考量
    if (memo[n] != 0) 
        memo[n] =  fibonacci0(memo, n - 1) + fibonacci(memo, n - 2);
    return memo[n];
}

// 动态规划，自底向上
fibonacci(int[] memo, int n) {
    for(int i = 3; i <= n; i++) 
        memo[i] = memo[i - 1] + memo[i - 2];
    return memo[n];
}

```

