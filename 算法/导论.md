#### 基础常识

``` tex
时钟周期  t = 1 / f(主频)
机器周期：包含多个时钟周期
指令周期：包含多个机器周期
MIPS：每秒执行百万指令数
1s之内解决问题：
On2处理104级别数据
On算法处理108级别数据
```

#### 知识点掌握

``` tex
排序
基础数据结构： 链表，栈，队列，哈希表
高级数据结构：堆，二叉树，图
基础算法：深度优先，广度优先，递归
基本算法思想：递归，分支，回溯，贪心，动态规划
```

#### 主定理

``` js
/*
 * 递归函数的时间复杂度： 主定理
 */
```



#### 优化

``` js
/*
遍历常见算法思路
遍历常见数据结构
空间换时间（哈希表）
*/
```



#### 双指针

+ 对撞指针

``` js
/*

*/
```

+ 滑动窗口

``` js
/*

*/
```

#### 问题类型

``` js
// 字符串
// 数组
// 链表
// 栈（模拟递归）
// 队列（树层次遍历，无权图最短路径）
// 递归 100，101，110，111，112（基准情形），113，129，222，257，404
// BST 108，230，450

/**
 * 回溯（树型结构，树的叶节点对应终结状态）
 * 是一个暴力解法（使用减支，动态规划来优化）
 * 17，46（状态恢复），37，39，40，47，51（N-Queens），52，77，78，90，216，401
 *
 * 二维平面回溯
 * 79，130，200（floodfill），417
 */

```

##### 回溯

> tips
>
> **核心是在for循环递归，在调用递归之前做出选择，递归之后撤销选择**
>
> 1 有重复路径时需要排除在 **递归同层的重复路径**
>
> 2 **在for循环提前判断是否满足条件，减少递归深度**

``` js
/*
 回溯（树型结构问题，树的叶节点对应终结状态）
 
 result = [];
 // 当前路径携带条件
 def backtrace(当前路径，选择列表)
 	if (满足结束条件)
 		result.add(路径)
 		return
    for (选择 in 选择列表)
    	做选择
    	backtrace(选择向基准情形递进， 选择列表)
    	撤销选择（状态回溯）
*/
```

##### 动态规划

> tips
>
> **定义状态**
>
> **状态转移方程**

``` java
/**
 * 动态规划
 * 递归 | 记忆化搜索是自顶向下解决问题。
 * 动态规划自底向上解决问题。
 *
 * 求一个问题的最优解（最大最小值）
 * 1. 重叠子问题，最优子结构（原问题的最优解依赖于各个子问题的最优解）
 *		子问题的最优解，可以存储起来（通常是一维或二维数组）
 * 2. 每一步面临若干选择，由于我们事先不知道最优解，只好遍历所有可能并比较得到最优解
 *
 * 贪心算法不一样，基于一个贪婪选择，我们确定能得到最优解，需要用数学的方式证明贪心选择的正确性
 */

// 递归
long fibonacci(int n) {
    in (n < 2)
        return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// int[] memo = new int[n + 1];
// memo[1] = 1;
// memo[2] = 1;

// 记忆化递归，自顶向下
long fibonacci(int[] memo, int n) {
    // 初值需要考量
    if (memo[n] != 0) 
        memo[n] =  fibonacci0(memo, n - 1) + fibonacci(memo, n - 2);
    return memo[n];
}

// 动态规划，自底向上
fibonacci(int[] memo, int n) {
    for(int i = 3; i <= n; i++) 
        memo[i] = memo[i - 1] + memo[i - 2];
    return memo[n];
}
```

