### 1 对象的概念

> 面向对象编程（Object-Oriented Programming OOP）是一种编程思维方式和编码架构



#### 抽象

所有编程语言都提供抽象机制。从某种程度上来说，问题的复杂度直接取决于抽象的类型和质量。这里的“类型”意思是：抽象的内容是什么？

汇编语言是对底层机器的轻微抽象。接着出现的“命令式”语言（如BASIC 和 C）是对汇编语言的抽象



#### 封装

1. `public`（公开）表示任何人都可以访问和使用该元素；
2. `private`（私有）除了类本身和类内部的方法，外界无法直接访问该元素。`private` 是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；
3. `protected`（受保护）类似于 `private`，区别是子类（下一节就会引入继承的概念）可以访问 `protected` 的成员，但不能访问 `private` 成员；
4. `default`（默认）如果你不使用前面的三者，默认就是 `default` 访问权限。`default` 被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。



#### 复用

+ **组合**（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。
+ **聚合**（Aggregation）动态的组合。

> 实线实心▲表示组合，实线空心◁表示聚合
>
> 译者注：组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义
>
> 整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件
>
> 两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系



#### 继承

如果继承一个类而不做其他任何事，则来自基类接口的方法直接进入派生类。这意味着派生类和基类不仅具有相同的类型，而且具有相同的行为，这么做没什么特别意义。

继承：子类有两种方式处理：

+ 子类中添加新的方法（“像是一个，is like a“）
+ 子类只覆盖（overriding）基类的方法（”是一个， is a“），子类纯粹替代父类



#### 多态

多个子类继承自父类，那编译器如何确定执行哪一个具体的方法呢？

**早期 / 静态绑定**，由非OOP编译器（C）产生的函数调用

**后期 / 动态绑定**，面向对象语言使用，被调用代码直到运行时才确定（编译器确定方法存在，并对参数和返回值执行类型检查，但它不知道要执行的确切代码）

> 为了执行后期绑定，Java使用一个特殊的代码来代替绝对调用
>
> 这段代码使用对象中存储的信息（对象头中类型信息）来计算方法主体的地址
>
> 因此，每个对象的行为会正确执行，**在Java中动态绑定是默认行为，C++需显式virtual关键字**



`shape = new Cricle()`向上转型，”利用这种方法解耦程序“

除非我们能确定元素类型，否则”向下转型“是不安全的



#### 集合

与参数化类型机制（泛型）密不可分

List

Map

Set

Queue

Tree

Stack

Heap（PriorityQueue，最小堆）



####  对象创建与生命周期

+ 静态内存分配

在 C++ 设计中采用的观点是效率第一，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。这种控制在某些情况下非常有用。

+ 动态内存分配

第二种方法是在堆内存（Heap）中动态地创建对象。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。 因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。

> 在栈内存开辟和释放空间通常是一条将栈指针向下，向上移动的汇编指令。
>
> 开辟堆内存空间的时间取决于内存机制的设计。
>
> ==在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它==



#### 异常处理

Java 从一开始就内置了异常处理，因此你不得不使用它。这是 Java 语言唯一接受的错误报告方法。如果没有编写适当的异常处理代码，你将会收到一条编译时错误消息



### 3 对象

> 如果我们说另外一种不同的语言，我们会发觉一个不同的世界！— Ludwig Wittgenstein (1889-1951)



#### *数据存储

1. **寄存器**（Registers）最快的存储区域，位于 CPU 内部 [^2](https://lingcoder.gitee.io/onjava8/#/大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。)。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。
2. **栈内存**（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。
3. **堆内存**（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 `new` 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
4. **常量存储**（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 （一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中（也在堆中））
5. **非 RAM 存储**（Non-RAM storage，外部记录介质）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。



#### 基本类型的存储

基本类型的创建方法，Java 使用了和 C/C++ 一样的策略。也就是说，不是使用 `new` 创建变量，而是使用一个“自动”变量。 这个变量直接存储"值"，并置于栈内存中，因此更加高效。



| 基本类型 | 大小    | 最小值    | 最大值         | 包装类型  |
| -------- | ------- | --------- | -------------- | --------- |
| boolean  | —       | —         | —              | Boolean   |
| char     | 16 bits | Unicode 0 | Unicode 216 -1 | Character |
| byte     | 8 bits  | -128      | +127           | Byte      |
| short    | 16 bits | - 215     | + 215 -1       | Short     |
| int      | 32 bits | - 231     | + 231 -1       | Integer   |
| long     | 64 bits | - 263     | + 263 -1       | Long      |
| float    | 32 bits | IEEE754   | IEEE754        | Float     |
| double   | 64 bits | IEEE754   | IEEE754        | Double    |
| void     | —       | —         | —              | Void      |

所有数值都为”有符号数“



#### 高精度数值

`BigInteger支持任意精度整数, BigDecimal支持任意类型浮点数`

牺牲速度换取精度



#### 数组的存储

在Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。==这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价==的，但由此换来的安全性和效率的提高是值得的。（并且 Java 经常可以优化这些操作）。



#### 对象作用域

Java对象与基本类型具有不同的生命周期，当我们使用 `new` 关键字来创建 Java 对象时，它的生命周期将会超出”{}“作用域

`{ String s = new String("str") }`

花括号之后，引用s作用域结束，我们无法在作用域后访问这个对象，但”str“还在堆内存中



#### static关键字

==方法名和参数列表统称为**方法签名**（signature of the method）。签名作为方法的唯一标识==

当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例 。

 即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段（或者类方法，类字段）



### 4 运算符

+ 逻辑运算
+ 位运算
+ 指数计数法
+ 截断和舍入
+ 类型提升（byte，char，short —> int，如果想再赋值回去那么需要强制转型）



### 5 控制流

#### 5.1 逗号操作符

`for(int x = 0, y = 0; x < 10 && y < 10; ++x, y += 2)`

只允许在for块使用逗号操作符



#### 5.2 标签

标签应用场景受限，只能声明在循环之前

``` java
outer:
for (int x = 0; x < 9; ++x) {
    inner:
    for (int y = 0; y <= x; ++y)
        souf("x * y = %d", x * y);
    println();
}

/**
 * break outer; 终止整个循环
 * continue outer; 终止内层循环，从下一次外层循环继续
 * break inner = continue outer
 * continue inner; 跳过当前内层循环
 */
```



#### 5.3 Switch

+ lookupswitch（O(logN)）
+ tableswitch（O(1)）



### 6 初始化和清理



### 7 封装



### 8 复用



### 9 多态



### 10 接口



### 11 内部类



### 12 集合



### 13 函数式编程



### 14 流式编程



### 15 异常



### 16 代码校验



### 17 文件



### 18 字符串



### 19 类型信息



### 20 泛型



### 21 数组



### 22 枚举



### 23 注解



### 24 并发编程



### 25 设计模式



### 附录



#### 1 对象传递和返回



#### 2 流式I/O



#### 3 标准I/O



#### 4 新I/O



#### 5 理解equals和hashCode



#### 6 集合



#### 7 并发底层原理



#### 8 数据压缩



#### 9 对象序列化



#### 10 静态语言类型检查



#### 11 C++与Java

